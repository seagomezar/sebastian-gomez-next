{"ast":null,"code":"var _jsxFileName = \"/Users/s.gomez/Desktop/sebastian-gomez/pages/posts/todo-sobre-transiciones-en-css.md\";\nvar __jsx = React.createElement;\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nimport React from 'react';\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return mdx(\"div\", _extends({}, props, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 10\n    },\n    __self: this\n  }));\n};\n\nconst layoutProps = {};\nconst MDXLayout = \"wrapper\";\nexport default function MDXContent(_ref) {\n  let {\n    components\n  } = _ref,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 21\n    },\n    __self: this\n  }), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 22\n    },\n    __self: this\n  }, `Las transiciones hacen parte del conjunto de herramientas que poseemos como desarrolladores FrontEnd para mejorar la experiencia del usuario dentro de nuestra aplicación Web. Son útiles porque nos permiten animar el cambio de valores en las distintas propiedades de un elemento lo que puede hacerlo más llamativo al usuario e invitarlo a interactuar con él. En este post trataré de cubrir el extenso tema de transiciones con diversos ejemplos adaptados desde la especificación.`), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 23\n    },\n    __self: this\n  }, `Empecemos con un ejemplo simple:`), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 24\n    },\n    __self: this\n  }, `Tenemos un cuadrado simple:`), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 25\n    },\n    __self: this\n  }, `\\`\\`'`), mdx(\"div\", {\n    id: \"square1\",\n    class: \"square red\",\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 26\n    },\n    __self: this\n  }), mdx(\"pre\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 27\n    },\n    __self: this\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 27\n    },\n    __self: this\n  }), `\nY unos estilos asociados a dicho cuadrado:\n\n\\`\\`css\n.square {\nwidth: 50px;\nheight: 50px;\nmargin-bottom: 5px;\n}\n.red { background: red; }\n\n`)), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 39\n    },\n    __self: this\n  }, `Y tenemos una clase adicional que se la asignaremos al cuadrado en un momento x en el tiempo:`), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 40\n    },\n    __self: this\n  }, `\\`\\`css\n.black {\nbackground: black;\n}`), mdx(\"pre\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 44\n    },\n    __self: this\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 44\n    },\n    __self: this\n  }), `\nSin embargo queremos que esto se haga de una manera suave, controlada y agradable al usuario. Por tanto es aquí donde necesitamos hacer uso de las transiciones. Esto lo podemos hacer añadiendo la propiedad transition dentro de la clase que queremos añadir:\n\n\\`\\`css\n.black {\nbackground: black;\ntransition: background 2s 0.25s;\n}\n\n`)), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 54\n    },\n    __self: this\n  }, `La propiedad transition como la hemos usado en el ejemplo anterior nos permite que el cambio de background de rojo a negro se haga durante 2 segundos (duración) en vez de hacer el cambio instantáneamente, también nos permite indicar que este cambio empiece a ocurrir 0.25 segundos después de que asigne la clase al elemento (delay).\nTambién existe otra sintaxis alternativa para esto que requiere unas cuantas líneas más, sin embargo es útil conocerla:`), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 56\n    },\n    __self: this\n  }, `\\`\\`css\n.black {\nbackground: black;\ntransition-property: background;\ntransition-duration: 2s;\ntransition-delay: 0.25s;\n}`), mdx(\"pre\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 63\n    },\n    __self: this\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 63\n    },\n    __self: this\n  }), `\nAnalogamente a los valores que hemos asignado en segundo a la duración y al retraso (delay) podríamos haberlo hecho en milisegundos, para lo cual bastaría con multiplicar por 1000 y añadir ms al final. Por ejemplo:\n\n\\`\\`css\n...\ntransition-duration: 2000ms;\ntransition-delay: 250ms;\n...\n\n`)), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 73\n    },\n    __self: this\n  }, `Si queremos hacer transiciones sobre más de una propiedad, podemos usar all para indicar que la transición se aplica sobre todas las propiedades posibles:`), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 74\n    },\n    __self: this\n  }, `\\`\\`css\n.black {\nbackground: black;\ncolor: white;\ntransition: all 2s 0.25s;\n}`), mdx(\"pre\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 80\n    },\n    __self: this\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 80\n    },\n    __self: this\n  }), `\n**Nota**: Transition all no es recomendable desde el punto de vista de desempeño (performance) altamente recomendamos no usar transition all a menos que definitivamente quieras aplicar transiciones sobre todo lo que pase con el elemento de la misma manera, por eso a continuación te explico como hacer transiciones específicamente con cada propiedad.\n\nA veces no deseamos que se hagan transiciones sobre todas las propiedades de la misma manera, la propiedad transition además tiene la característica de permitir especificar la transición de cada propiedad simplemente separándolas por coma. Veamos un ejemplo:\n\n\\`\\`css\n.black {\nbackground: black;\ncolor: white;\ntransition: background 2s 0.25s,\ncolor 1.5 3s;\n}\n\n`)), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 94\n    },\n    __self: this\n  }, `En el ejemplo anterior estamos cambiando el background y el color con distinta duración y distinto retraso (delay). Esto permite tener un control mas granular de exactamente lo que necesitamos animar en cada transición.`), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 95\n    },\n    __self: this\n  }, `Como habrás notado hasta ahora las transiciones de las que hablamos ocurren de manera lineal, esto quiere decir que el cambio ocurre uniformemente durante el tiempo que dure la transición, sin embargo esta no es la única manera de hacerlo, por ejemplo podemos acelerar el cambio al comienzo y desacelerarlo al final lo que nos dará un tipo diferente de sensación al ver la transición. Para determinar como ocurrirá el cambio, tenemos la propiedad transition-timing-function que puede tomar los siguientes valores:`), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 96\n    },\n    __self: this\n  }, `\\`\\`css\ntransition-timing-function: linear; // Este es el valor por defecto, no hace falta incluirlo\ntransition-timing-function: ease-in; // Significa que al comienzo sea rápido el cambio y que después se ralentice.\ntransition-timing-function: ease-out; // Significa que al comienzo sea lento el cambio y que después se acelere.\ntransition-timing-function: ease-in-out; // Significa que al comienzo y al final sea rápido el cambio pero en la mitad sea lento\ntransition-timing-function: cubic-bezier(0.21,0.3,0.1,0.23); // De acuerdo a los valores se acelera o desacelera en los distintos momentos en que ocurre la transición.`), mdx(\"pre\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 102\n    },\n    __self: this\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 102\n    },\n    __self: this\n  }), `\nPero esta no es la única manera de añadir esta propiedad a las transiciones. También es posible hacerlo directamente en la propiedad transition:\n\n\\`\\`css\n.move {\ntransform: translateX(500px);\ntransition: transform 2s 0.25s ease-in-out;\n}\n\n`)), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112\n    },\n    __self: this\n  }, `Incluso en cada transición sobre las propiedades:`), mdx(\"p\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113\n    },\n    __self: this\n  }, `\\`\\`css\n.move-background {\ntransform: translateX(500px);\nbackground: red;\ntransition: transform 2s 0.25s ease-in-out,\nbackground 1s 0.10 cubic-bezier(0.21,0.3,0.1,0.23);\n}`), mdx(\"pre\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 120\n    },\n    __self: this\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 120\n    },\n    __self: this\n  }), `\nMiremos en detalle un poco más como funciona la propiedad transition-timing-function cuando toma el valor de cubic-bezier(). Para ello revisemos en que consiste la ecuación de la curva de bezier en la cual se basa esta función.\n\nLas curvas de bezier son un sistema matemático que desarrollo pierre bezier para el trazado de dibujos de aeronaves y automóviles que se describe como una ecuación que toma cuatro valores para describir la curva:\n\n[![](https://storage.googleapis.com/sebastian-gomez-blog.appspot.com/uploads/2018/01/23242B8E-A920-4955-84E1-C7D2563CD969.png)](https://storage.googleapis.com/sebastian-gomez-blog.appspot.com/uploads/2018/01/23242B8E-A920-4955-84E1-C7D2563CD969.png) Con una ecuación matemática de la siguiente forma: [![](https://storage.googleapis.com/sebastian-gomez-blog.appspot.com/uploads/2018/01/Screen-Shot-2018-01-09-at-4.13.37-PM-1024x53.png)](https://storage.googleapis.com/sebastian-gomez-blog.appspot.com/uploads/2018/01/Screen-Shot-2018-01-09-at-4.13.37-PM.png)\n\nPues bien estos cuatro valores (P0 a P3) son los que describen la transición del movimiento entre el punto inicial y el punto final y con estos se pueden definir completamente diversos tipos de transiciones:\n\ncubic-bezier(P0, P1, P2, P3); En estos sitios web puedes jugar más con este tipo de transiciones donde puedes ajustar los valores para tener un mayor control en tu transición:\n\n- [http://cubic-bezier.com/](http://cubic-bezier.com/)\n- [http://easings.net/](http://easings.net/)\n\nDebes tener en cuenta que hay propiedades que no son “transicionables” esto quiere decir que no puedes aplicar transiciones a estas propiedades. Para ver una lista de cuales propiedades son “transicionables\" y cuales no puedes revisar este link:\n\n[https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties)\n\nEn el siguiente ejemplo se muestra un conjunto de transiciones sobre cubos con distintas transition-timing-function y propiedades, puedes jugar con ellas para evidenciar sus diferencias:\n\nhttps://codepen.io/seagomezar/pen/wPbYqe\n\nLas herramientas para desarrolladores de los navegadores como chrome y firefox nos permiten ralentizar o acelerar las transformaciones para un mejor proceso de debug en ellas, para ello puedes abrir la pestaña animaciones:\n\n[![](https://storage.googleapis.com/sebastian-gomez-blog.appspot.com/uploads/2018/01/13B715EC-945A-47A7-A6E8-F6A79F24AE3D-1024x642.png)](https://storage.googleapis.com/sebastian-gomez-blog.appspot.com/uploads/2018/01/13B715EC-945A-47A7-A6E8-F6A79F24AE3D.png)\n\nPuedes también usar Javascript para conocer el estado de una transición mediante los siguientes listeners:\n\n- transitionstart\n- transitionend\n\nFinalmente algunas consideraciones respecto a las transiciones:\n\n- Transiciones alrededor de 100ms son instantáneas para los usuarios y difícilmente perceptibles.\n- Transiciones de máximo 1 segundo y mínimo 250ms son buenas y mantiene a los usuario conectados.\n- Mas de 2 segundos es definitivamente una mala idea para transformaciones en sitios web estándar ya que puede desconectar al usuario de lo que pasa.\n- De 250ms a 300ms es el tiempo estándar de la mayoría de animaciones.\n- Las transiciones en general te permite crear experiencias que pasan solo una vez.\n- Si el navegador no soporta transiciones en el peor de los casos siempre se cambia la propiedad.\n- Las transiciones son granulares porque te permiten animar una o dos o x propiedades.\n\nEso es todo, espero que este post te sea de utilidad y lo puedas aplicar a algún proyecto que tengas en mente y que simplemente te haya ayudado a entender la naturaleza de las transiciones en CSS. Déjame un comentario si lograste implementarlo, si quieres añadir alguna otra funcionalidad o si tienes alguna duda no dudes en dejarme un comentario en la parte de abajo, recuerda que si te gustó también puedes compartir usando los links a las redes sociales en la parte de abajo.\n\n`)), mdx(\"pre\", {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 164\n    },\n    __self: this\n  }, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}, {\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 164\n    },\n    __self: this\n  }), ``)));\n}\n;\nMDXContent.isMDXComponent = true;","map":{"version":3,"sources":["/Users/s.gomez/Desktop/sebastian-gomez/pages/posts/todo-sobre-transiciones-en-css.md"],"names":["React","mdx","makeShortcode","name","MDXDefaultShortcode","props","console","warn","layoutProps","MDXLayout","MDXContent","components","isMDXComponent"],"mappings":"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","sourcesContent":["\nimport React from 'react'\nimport { mdx } from '@mdx-js/react'\n\n/* @jsx mdx */\n\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\")\n  return <div {...props}/>\n};\n\nconst layoutProps = {\n  \n};\nconst MDXLayout = \"wrapper\"\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n    <p>{`Las transiciones hacen parte del conjunto de herramientas que poseemos como desarrolladores FrontEnd para mejorar la experiencia del usuario dentro de nuestra aplicación Web. Son útiles porque nos permiten animar el cambio de valores en las distintas propiedades de un elemento lo que puede hacerlo más llamativo al usuario e invitarlo a interactuar con él. En este post trataré de cubrir el extenso tema de transiciones con diversos ejemplos adaptados desde la especificación.`}</p>\n    <p>{`Empecemos con un ejemplo simple:`}</p>\n    <p>{`Tenemos un cuadrado simple:`}</p>\n    <p>{`\\`\\`'`}</p>\n    <div id=\"square1\" class=\"square red\"></div>\n    <pre><code parentName=\"pre\" {...{}}>{`\nY unos estilos asociados a dicho cuadrado:\n\n\\`\\`css\n.square {\nwidth: 50px;\nheight: 50px;\nmargin-bottom: 5px;\n}\n.red { background: red; }\n\n`}</code></pre>\n    <p>{`Y tenemos una clase adicional que se la asignaremos al cuadrado en un momento x en el tiempo:`}</p>\n    <p>{`\\`\\`css\n.black {\nbackground: black;\n}`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`\nSin embargo queremos que esto se haga de una manera suave, controlada y agradable al usuario. Por tanto es aquí donde necesitamos hacer uso de las transiciones. Esto lo podemos hacer añadiendo la propiedad transition dentro de la clase que queremos añadir:\n\n\\`\\`css\n.black {\nbackground: black;\ntransition: background 2s 0.25s;\n}\n\n`}</code></pre>\n    <p>{`La propiedad transition como la hemos usado en el ejemplo anterior nos permite que el cambio de background de rojo a negro se haga durante 2 segundos (duración) en vez de hacer el cambio instantáneamente, también nos permite indicar que este cambio empiece a ocurrir 0.25 segundos después de que asigne la clase al elemento (delay).\nTambién existe otra sintaxis alternativa para esto que requiere unas cuantas líneas más, sin embargo es útil conocerla:`}</p>\n    <p>{`\\`\\`css\n.black {\nbackground: black;\ntransition-property: background;\ntransition-duration: 2s;\ntransition-delay: 0.25s;\n}`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`\nAnalogamente a los valores que hemos asignado en segundo a la duración y al retraso (delay) podríamos haberlo hecho en milisegundos, para lo cual bastaría con multiplicar por 1000 y añadir ms al final. Por ejemplo:\n\n\\`\\`css\n...\ntransition-duration: 2000ms;\ntransition-delay: 250ms;\n...\n\n`}</code></pre>\n    <p>{`Si queremos hacer transiciones sobre más de una propiedad, podemos usar all para indicar que la transición se aplica sobre todas las propiedades posibles:`}</p>\n    <p>{`\\`\\`css\n.black {\nbackground: black;\ncolor: white;\ntransition: all 2s 0.25s;\n}`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`\n**Nota**: Transition all no es recomendable desde el punto de vista de desempeño (performance) altamente recomendamos no usar transition all a menos que definitivamente quieras aplicar transiciones sobre todo lo que pase con el elemento de la misma manera, por eso a continuación te explico como hacer transiciones específicamente con cada propiedad.\n\nA veces no deseamos que se hagan transiciones sobre todas las propiedades de la misma manera, la propiedad transition además tiene la característica de permitir especificar la transición de cada propiedad simplemente separándolas por coma. Veamos un ejemplo:\n\n\\`\\`css\n.black {\nbackground: black;\ncolor: white;\ntransition: background 2s 0.25s,\ncolor 1.5 3s;\n}\n\n`}</code></pre>\n    <p>{`En el ejemplo anterior estamos cambiando el background y el color con distinta duración y distinto retraso (delay). Esto permite tener un control mas granular de exactamente lo que necesitamos animar en cada transición.`}</p>\n    <p>{`Como habrás notado hasta ahora las transiciones de las que hablamos ocurren de manera lineal, esto quiere decir que el cambio ocurre uniformemente durante el tiempo que dure la transición, sin embargo esta no es la única manera de hacerlo, por ejemplo podemos acelerar el cambio al comienzo y desacelerarlo al final lo que nos dará un tipo diferente de sensación al ver la transición. Para determinar como ocurrirá el cambio, tenemos la propiedad transition-timing-function que puede tomar los siguientes valores:`}</p>\n    <p>{`\\`\\`css\ntransition-timing-function: linear; // Este es el valor por defecto, no hace falta incluirlo\ntransition-timing-function: ease-in; // Significa que al comienzo sea rápido el cambio y que después se ralentice.\ntransition-timing-function: ease-out; // Significa que al comienzo sea lento el cambio y que después se acelere.\ntransition-timing-function: ease-in-out; // Significa que al comienzo y al final sea rápido el cambio pero en la mitad sea lento\ntransition-timing-function: cubic-bezier(0.21,0.3,0.1,0.23); // De acuerdo a los valores se acelera o desacelera en los distintos momentos en que ocurre la transición.`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`\nPero esta no es la única manera de añadir esta propiedad a las transiciones. También es posible hacerlo directamente en la propiedad transition:\n\n\\`\\`css\n.move {\ntransform: translateX(500px);\ntransition: transform 2s 0.25s ease-in-out;\n}\n\n`}</code></pre>\n    <p>{`Incluso en cada transición sobre las propiedades:`}</p>\n    <p>{`\\`\\`css\n.move-background {\ntransform: translateX(500px);\nbackground: red;\ntransition: transform 2s 0.25s ease-in-out,\nbackground 1s 0.10 cubic-bezier(0.21,0.3,0.1,0.23);\n}`}</p>\n    <pre><code parentName=\"pre\" {...{}}>{`\nMiremos en detalle un poco más como funciona la propiedad transition-timing-function cuando toma el valor de cubic-bezier(). Para ello revisemos en que consiste la ecuación de la curva de bezier en la cual se basa esta función.\n\nLas curvas de bezier son un sistema matemático que desarrollo pierre bezier para el trazado de dibujos de aeronaves y automóviles que se describe como una ecuación que toma cuatro valores para describir la curva:\n\n[![](https://storage.googleapis.com/sebastian-gomez-blog.appspot.com/uploads/2018/01/23242B8E-A920-4955-84E1-C7D2563CD969.png)](https://storage.googleapis.com/sebastian-gomez-blog.appspot.com/uploads/2018/01/23242B8E-A920-4955-84E1-C7D2563CD969.png) Con una ecuación matemática de la siguiente forma: [![](https://storage.googleapis.com/sebastian-gomez-blog.appspot.com/uploads/2018/01/Screen-Shot-2018-01-09-at-4.13.37-PM-1024x53.png)](https://storage.googleapis.com/sebastian-gomez-blog.appspot.com/uploads/2018/01/Screen-Shot-2018-01-09-at-4.13.37-PM.png)\n\nPues bien estos cuatro valores (P0 a P3) son los que describen la transición del movimiento entre el punto inicial y el punto final y con estos se pueden definir completamente diversos tipos de transiciones:\n\ncubic-bezier(P0, P1, P2, P3); En estos sitios web puedes jugar más con este tipo de transiciones donde puedes ajustar los valores para tener un mayor control en tu transición:\n\n- [http://cubic-bezier.com/](http://cubic-bezier.com/)\n- [http://easings.net/](http://easings.net/)\n\nDebes tener en cuenta que hay propiedades que no son “transicionables” esto quiere decir que no puedes aplicar transiciones a estas propiedades. Para ver una lista de cuales propiedades son “transicionables\" y cuales no puedes revisar este link:\n\n[https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties)\n\nEn el siguiente ejemplo se muestra un conjunto de transiciones sobre cubos con distintas transition-timing-function y propiedades, puedes jugar con ellas para evidenciar sus diferencias:\n\nhttps://codepen.io/seagomezar/pen/wPbYqe\n\nLas herramientas para desarrolladores de los navegadores como chrome y firefox nos permiten ralentizar o acelerar las transformaciones para un mejor proceso de debug en ellas, para ello puedes abrir la pestaña animaciones:\n\n[![](https://storage.googleapis.com/sebastian-gomez-blog.appspot.com/uploads/2018/01/13B715EC-945A-47A7-A6E8-F6A79F24AE3D-1024x642.png)](https://storage.googleapis.com/sebastian-gomez-blog.appspot.com/uploads/2018/01/13B715EC-945A-47A7-A6E8-F6A79F24AE3D.png)\n\nPuedes también usar Javascript para conocer el estado de una transición mediante los siguientes listeners:\n\n- transitionstart\n- transitionend\n\nFinalmente algunas consideraciones respecto a las transiciones:\n\n- Transiciones alrededor de 100ms son instantáneas para los usuarios y difícilmente perceptibles.\n- Transiciones de máximo 1 segundo y mínimo 250ms son buenas y mantiene a los usuario conectados.\n- Mas de 2 segundos es definitivamente una mala idea para transformaciones en sitios web estándar ya que puede desconectar al usuario de lo que pasa.\n- De 250ms a 300ms es el tiempo estándar de la mayoría de animaciones.\n- Las transiciones en general te permite crear experiencias que pasan solo una vez.\n- Si el navegador no soporta transiciones en el peor de los casos siempre se cambia la propiedad.\n- Las transiciones son granulares porque te permiten animar una o dos o x propiedades.\n\nEso es todo, espero que este post te sea de utilidad y lo puedas aplicar a algún proyecto que tengas en mente y que simplemente te haya ayudado a entender la naturaleza de las transiciones en CSS. Déjame un comentario si lograste implementarlo, si quieres añadir alguna otra funcionalidad o si tienes alguna duda no dudes en dejarme un comentario en la parte de abajo, recuerda que si te gustó también puedes compartir usando los links a las redes sociales en la parte de abajo.\n\n`}</code></pre>\n    <pre><code parentName=\"pre\" {...{}}>{``}</code></pre>\n    </MDXLayout>;\n}\n\n;\nMDXContent.isMDXComponent = true;"]},"metadata":{},"sourceType":"module"}