_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[31],{"/xsG":function(e,n,a){"use strict";a.r(n),a.d(n,"default",(function(){return m}));var r=a("wx14"),o=a("Ff2n"),t=a("q1tI"),s=a.n(t),c=a("7ljp"),i=a("j53b"),l=a("6G3q"),u=a("37hk"),b=(s.a.createElement,{});function m(e){var n=e.components,a=Object(o.a)(e,["components"]);return Object(c.b)("wrapper",Object(r.a)({},b,a,{components:n,mdxType:"MDXLayout"}),Object(c.b)(l.a,{category:"Javascript",date:"2020-05-05",title:"Implementando map como operador en Observables",slug:"implementando-map-como-operador-en-observables",thumbnailImage:"/rxjs.png",excerpt:"En este post vamos a valernos de esta definici\xf3n para aumentar el n\xfamero de operadores que podemos implementar y usar dentro de un Observable.",mdxType:"HeadSite"}),Object(c.b)("h1",null,"Implementando map como operador en Observables"),Object(c.b)(i.a,{tags:["Javascript","Programaci\xf3n Reactiva","Desarrollo Web"],date:"2020-05-05",slug:"implementando-map-como-operador-en-observables",mdxType:"PostHeader"}),Object(c.b)("p",null,"En este post vamos a valernos de esta definici\xf3n para aumentar el n\xfamero de operadores que podemos implementar y usar dentro de un Observable."),Object(c.b)("p",null,"En el ",Object(c.b)("a",Object(r.a)({parentName:"p"},{href:"https://www.sebastian-gomez.com/implementando-observables-a-partir-de-eventos-en-js/"}),"post anterior")," tuvimos un primer acercamiento a la definici\xf3n m\xe1s pura de lo que es un Observable y lo implementamos desde cero similarmente a como lo hace RX.js. En este post vamos a valernos de esta definici\xf3n para aumentar el n\xfamero de operadores que podemos implementar y usar dentro de un Observable. Primero recordemos cual es la definici\xf3n m\xe1s pura de un observable con una funci\xf3n generadora de observables a partir de eventos:"),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"class Observable {\n  constructor(subscribe) {\n    this._subscribe = subscribe;\n  }\n  subscribe(observer) {\n    return this._subscribe(observer);\n  }\n  static fromEvent(domElement, eventName) {\n    return new Observable(function subscribe(observer) {\n      const handler = (ev) => {\n        observer.next(ev);\n      };\n      domElement.addEventListener(eventName, handler);\n      return {\n        unsubscribe() {\n          domElement.removeEventListener(eventName, handler);\n        },\n      };\n    });\n  }\n}\n")),Object(c.b)("p",null,"De esta manera tu puedes crear Observables que te devolver\xe1n informaci\xf3n del evento de la siguiente manera:"),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'    const button = document.getElementById("button");\n    const clicks = Observable.fromEvent(button, "click");\n    const clicksSubscription = clicks.subscribe({\n      next(e) {\n        console.log("Click in the button\u201d, e); // \u201ce\u201d contiene toda la informaci\xf3n del evento\n      }\n    });\n\n    clicksSubscription.unsubscribe(); // De esta manera te puedes des-suscribir\n')),Object(c.b)("p",null,"Sin embargo es probable que necesitemos hacer m\xe1s operaciones sobre la cadena de datos, imag\xednate si quiz\xe1 requiramos solamente obtener s\xf3lo algunos datos del evento por ejemplo solo la posici\xf3n del Mouse. O imag\xednate si s\xf3lo queremos escuchar por los clicks que se hagan en la parte izquierda del bot\xf3n. Pues bien vamos a implementar dos funciones que quiz\xe1 ya conozcas porque se usan principalmente para el procesamiento de arrays. Vamos a implementar la funci\xf3n \u201cmap\u201d sobre observables. Pero antes veamos un ejemplo sobre como es su funcionamiento sobre Arrays en javascript para luego traerlo a nuestra definici\xf3n de observables e implementarlo all\xed."),Object(c.b)("p",null,"Empecemos con la funci\xf3n map. La funci\xf3n map es una funci\xf3n pura que itera sobre cada elemento de un array y \u201cmapea\u201d cada item de un array en otro. Veamos un ejemplo:"),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"    [1, 2, 3\\].map( elemento => elemento * 2);\n    // Retorna [1, 4, 6]\n")),Object(c.b)("p",null,"Ahora bien \xbfComo hace internamente esta funci\xf3n para retornar este resultado? B\xe1sicamente la funci\xf3n map recibe como par\xe1metro una funci\xf3n de proyecci\xf3n o transformaci\xf3n y aplica dicha funci\xf3n a cada uno de los elementos que pasan como par\xe1metro. Esto hace que sin afectar el array original pueda devolver en nuevo arreglo con la funci\xf3n de proyecci\xf3n aplicada a cada item dentro del array. Veamos como ser\xeda la implementaci\xf3n de la funci\xf3n map para arrays:"),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"Array.prototype.map = function (projectionFunction) {\n  const results = [];\n  this.forEach(function (itemInArray) {\n    results.push(projectionFunction(itemInArray));\n  });\n  return results;\n};\n")),Object(c.b)("p",null,"\xbfHermosa no? Ahora que te parece si nos arriesgamos a escribir lo mismo para observables. Similarmente que para arreglos, vamos a necesitar como par\xe1metro una funci\xf3n de proyecci\xf3n que nos permita transformar cada valor que retorna el observable. Adicionalmente queremos retornar un observable tambi\xe9n al que nos podamos subscribir. Empecemos por solo esas dos cosas que te acab\xf3 de decir:"),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"    class Observable {\n      \u2026\n      map(projectionFunction) {\n        const self = this;\n        return new Observable(function subscribe(observer) {\n          const subscription = self.subscribe({\n            next(v) {\n            },\n            error (e) {\n            },\n            complete () {\n            }\n          });\n          return subscription;\n        });\n      }\n      \u2026\n    }\n")),Object(c.b)("p",null,"Simple, \xbfno? Como ver\xe1s hemos definido la funci\xf3n map que ya no es \u201cstatic\u201d ya que no se puede aplicar sobre la definici\xf3n abstracta de Observable sino sobre instancias de dicha clase. Adicionalmente recibimos como par\xe1metro una funci\xf3n de proyecci\xf3n que es la que transformar\xe1 cada valor que retorne la funci\xf3n interna next, y finalmente retornamos la subscripci\xf3n para que sea posible suscribirnos al observable que justo acabamos de crear. Veamos entonces como podemos aplicar la funci\xf3n de proyecci\xf3n a cada elemento que retornemos dentro de la funci\xf3n next."),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"    class Observable {\n      \u2026\n      map(projectionFunction) {\n        const self = this;\n        return new Observable(function subscribe(observer) {\n          const subscription = self.subscribe({\n            next(v) {\n                const value = projectionFunction(v);\n                observer.next(value);\n            },\n            error (e) {\n            },\n            complete () {\n            }\n          });\n          return subscription;\n        });\n      }\n      \u2026\n    }\n")),Object(c.b)("p",null,"Como ves no hicimos otra cosa que usar la funci\xf3n de transformaci\xf3n sobre cada valor que queremos enviar al observador. Eso es todo!, esta definida nuestra funci\xf3n map dentro de la definici\xf3n que tenemos de Observable. Ajustemos un poco m\xe1s esta definici\xf3n previniendo posibles errores inesperados:"),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"    class Observable {\n      \u2026\n      map(projection) {\n        const self = this;\n        return new Observable(function subscribe(observer) {\n          const subscription = self.subscribe({\n            next(v) {\n              let value;\n              try {\n                value = projection(v);\n                observer.next(value);\n              }\n              catch(e) {\n                observer.error(e);\n                subscription.unsubscribe();\n              }\n            },\n            error (e) {\n              observer.error(e);\n            },\n            complete () {\n              observer.complete();\n            }\n          });\n          return subscription;\n        });\n      }\n      \u2026\n    }\n")),Object(c.b)("p",null,"Con lo anterior queda completa nuestra funci\xf3n map en la definici\xf3n de observable. Veamos ahora como podemos usarla para transformar los datos dentro de nuestro observable, obteniendo solamente la posici\xf3n del mouse en el momento que hizo click sobre el bot\xf3n."),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),'const button = document.getElementById("button");\nconst clicks = Observable.fromEvent(button, "click");\nconst clicksSubscription = clicks\n  .map((ev) => ev.offsetX)\n  .subscribe({\n    next(offSetX) {\n      console.log(offSetX);\n    },\n  });\n')),Object(c.b)("p",null,"En el siguiente Codepen podr\xe1s revisar la definici\xf3n completa:"),Object(c.b)("ul",null,Object(c.b)("li",{parentName:"ul"},Object(c.b)("a",Object(r.a)({parentName:"li"},{href:"https://codepen.io/seagomezar/pen/zpgROb?editors=1011"}),"https://codepen.io/seagomezar/pen/zpgROb"))),Object(c.b)("p",null,"Eso es todo, espero que este post te sea de utilidad y lo puedas aplicar a alg\xfan proyecto que tengas en mente y que simplemente te haya ayudado a entender la naturaleza del operador map sobre observables. d\xe9jame un comentario si lograste implementarlo, si quieres a\xf1adir alguna otra funcionalidad o si tienes alguna duda no dudes en dejarme un comentario en la parte de abajo, recuerda que si te gust\xf3 tambi\xe9n puedes compartir usando los links a las redes sociales en la parte de abajo."),Object(c.b)(u.a,{slug:"implementando-map-como-operador-en-observables",mdxType:"Discuss"}))}m.isMDXComponent=!0},j53b:function(e,n,a){"use strict";var r=a("1OyB"),o=a("vuIU"),t=a("Ji7U"),s=a("md7G"),c=a("foSv"),i=a("MX0m"),l=a.n(i),u=a("q1tI"),b=a.n(u),m=(a("YFqc"),b.a.createElement);function p(e){var n=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var a,r=Object(c.a)(e);if(n){var o=Object(c.a)(this).constructor;a=Reflect.construct(r,arguments,o)}else a=r.apply(this,arguments);return Object(s.a)(this,a)}}var d={CSS:"primary",HTML:"secondary",Javascript:"warning",Firebase:"warning","Google Maps":"darkgreen",Angular:"danger",React:"success","Desarrollo Web":"info","Google Datastudio":"primary","Big Query":"danger",NodeJS:"node",Other:"dark",Typescript:"typescript","Programaci\xf3n Reactiva":"reactive"},v=function(e){Object(t.a)(a,e);var n=p(a);function a(){return Object(r.a)(this,a),n.apply(this,arguments)}return Object(o.a)(a,[{key:"render",value:function(){var e=this.props.name;return m("a",{className:"jsx-187945056 "+("badge badge-"+(d[e]||"dark")||!1)},e,m(l.a,{id:"187945056"},[".badge.jsx-187945056{-webkit-text-decoration:none;text-decoration:none;margin-right:1em;color:white;padding:0.5em 0.5em;margin:0.5em 0;display:inline-block;}",".badge-primary.jsx-187945056{background-color:blue;}",".badge-secondary.jsx-187945056{background-color:green;}",".badge-darkgreen.jsx-187945056{background-color:#3cba54;}",".badge-danger.jsx-187945056{background-color:red;}",".badge-warning.jsx-187945056{background-color:#e5be01;}",".badge-info.jsx-187945056{background-color:gray;}",".badge-dark.jsx-187945056{background-color:black;}",".badge-success.jsx-187945056{background-color:green;}",".badge-node.jsx-187945056{background-color:#11d92f;}",".badge-typescript.jsx-187945056{background-color:#4f8cf6;}",".badge-reactive.jsx-187945056{background-color:#e10c8c;}"]))}}]),a}(b.a.Component),f=b.a.createElement;function j(e){var n=function(){if("undefined"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"===typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var a,r=Object(c.a)(e);if(n){var o=Object(c.a)(this).constructor;a=Reflect.construct(r,arguments,o)}else a=r.apply(this,arguments);return Object(s.a)(this,a)}}var g=function(e){Object(t.a)(a,e);var n=j(a);function a(){return Object(r.a)(this,a),n.apply(this,arguments)}return Object(o.a)(a,[{key:"render",value:function(){var e=this.props,n=e.date,a=e.tags;e.slug;return f("small",{className:"jsx-1750184873 "},f("span",{className:"jsx-1750184873"},f("strong",{className:"jsx-1750184873"},"Fecha: "),new Date(n).toLocaleDateString("es-CO")," -",f("strong",{className:"jsx-1750184873"}," Autor: ")," Sebastian Gomez"),f("span",{className:"jsx-1750184873"}),f("span",{className:"jsx-1750184873"},a.map((function(e,n){return f(v,{name:e,key:n})}))),f(l.a,{id:"1750184873"},["a.jsx-1750184873{color:#9eabb3;-webkit-text-decoration:none;text-decoration:none;}","small.jsx-1750184873{color:#9eabb3;}","span.jsx-1750184873{display:block;}","span.jsx-1750184873:first-child{margin-top:0.2em;}","span.jsx-1750184873:last-child{margin-bottom:1em;}"]))}}]),a}(b.a.Component);n.a=g},mXpa:function(e,n,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/posts/implementando-map-como-operador-en-observables",function(){return a("/xsG")}])}},[["mXpa",0,1,2,3,4,5]]]);